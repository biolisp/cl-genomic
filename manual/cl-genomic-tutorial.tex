\documentclass[a4paper, 12pt]{article}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{wrapfig}
\renewcommand{\familydefault}{\sfdefault} % Use default sans-serif font

\usepackage{listings}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}

\lstloadlanguages{Lisp}

\lstset{
  basicstyle=\ttfamily\small,
  % numbers=left,numbersep=5pt,stepnumber=5,
  language=Lisp,
  backgroundcolor=\color{brown!20},
  keywordstyle=[1]{\ttfamily\color{blue}},
  keywordstyle=[2]{\itshape\color{blue}},
  morekeywords=[1]{handler-bind,with-open-file,while,with-sequence-residues},
  morekeywords=[2]{lambda},
  deletekeywords={collect,identity,length,list,mapcar,member,subseq},
  commentstyle=\color{red!90!green!90!blue},
  stringstyle=\color{brown},
  showstringspaces=false,
  captionpos=b}

\begin{document}

\title{The cl-genomic Tutorial}
\author{Keith James}
\date{\today}

\maketitle


\section{Creating bio-sequences}
\label{sec:creating-bioseq}

\subsection{Creating sequences from strings}
\label{sec:create-bioseq-str}

There exist three exported functions that create sequence objects from
strings; \lstinline!make-dna!, \lstinline!make-rna! and
\lstinline!make-aa!, creating DNA, RNA and amino-acid sequence objects
respectively.

Unless an \lstinline!:identifer! keyword argument is supplied, the
resulting object will be an anonymous sequence (i.e. will have an
identifier NIL and will return T if passed to the
\lstinline!anonymousp! predicate). A newly created nucleic-acid
sequence object will be double-stranded unless a
\lstinline!:num-strands! argument of 1 is supplied. The strandedness
of a sequence affects some operations. For example, it is not possible
to request an interval from the reverse-complement strand of a such a
sequence.

\begin{lstlisting}[caption={Making DNA sequences from strings},
  label=lst:make-dnaseq-string]
  (in-package :bio-sequence)
  
  ;; Create an anonymous DNA sequence
  (make-dna "gtaaaacgacggccagtg")
  
  ;; Use of characters illegal in DNA will cause an error
  (make-dna "guaaaacgacggccagug")

  ;; Create an identified, single-stranded DNA sequence 
  (make-dna "gtaaaacgacggccagtg" :identity 'm13-fwd :num-strands 1)

  ;; Create a DNA sequence with ambiguities
  (make-dna "gtanarygacggccagtg")

  ;; Create a 30bp virtual DNA sequence
  (make-dna nil :length 30)
\end{lstlisting}

All sequences support the full IUPAC character set
\cite{PMID:2582368}. Alternatively, sequences may be created without
any explicit residues, supplying instead a \lstinline!:length!
initialization argument. The resulting object will be a virtual
sequence (i.e. will be composed implicitly of ambiguous residues and
will return T if passed to the \lstinline!virtualp!
predicate). Virtual sequences are useful for representing the relative
positions of sequence intervals where knowledge of the residues is not
required.

\subsection{Reading sequences from streams}
\label{sec:read-bioseq-stream}

Reading DNA, RNA or amino-acid sequences from a stream is essentially
a chunking operation; data such as sequence metadata and residue
characters are gathered until a complete sequence record has been
read, then the gathered data are processed in some way.

The generic function \lstinline!make-seq-input! is the entry point for
reading from streams. There are several methods available, all of
which accept two mandatory arguments; a stream designator (a string
naming a file, a pathname or a stream) and a format symbol. The
\lstinline!:alphabet! argument is used to specify the sequence
alphabet (\lstinline!:dna!, \lstinline!:rna! or \lstinline!:aa!,
defaulting to \lstinline!:dna!). Other keyword arguments are available
(see the API reference). The value returned is a generator function (a
closure, in fact) that may be passed to the general-purpose generator
API functions \lstinline!has-more-p! and \lstinline!next! to return
sequences.

The parsers offer restarts for occasions where badly formatted
sequence records are encountered, allowing such records to be skipped,
logged or otherwise handled using the standard CL (Common Lisp)
condition and restart system. The error conditions raised by the
parser will be \lstinline!general-parse-error!s, or a subtype thereof.

The basic restart function is \lstinline!skip-malformed-sequence!
which causes the generator to return NIL and moves the stream forward
to the next record.

\begin{lstlisting}[caption={Making sequences from streams},
  label=lst:read-bioseq-stream]
  (in-package :bio-sequence)
  
  ;; Read Fasta format DNA sequences from a named file into a list
  (with-open-file (stream "seq.fasta")
      (let ((g (make-seq-input stream :fasta)))
        (loop
           while (has-more-p g)
           collect (next g))))

  ;; Read a single AA sequence from a stream
  (next (make-seq-input stream :fasta :alphabet :aa))

  ;; Read the human genome in Fasta format from a file and print
  ;; chromosome names and lengths
  (with-open-file (stream "Homo_sapiens.NCBI36.52.dna.toplevel.fa")
      (let ((g (make-seq-input stream :fasta :virtual t)))
        (loop
           while (has-more-p g)
           do (let ((seq (next g)))
                (format t "~a ~a~%" (identity-of seq)
                        (length-of seq))))))

  ;; Read Fasta format DNA sequences, using restarts to skip
  ;; bad records
  (with-open-file (stream "bad_seq.fasta")
      (handler-bind ((malformed-record-error
                        #'skip-malformed-sequence))
        (let ((g (make-seq-input stream :fasta)))
           (loop
              while (has-more-p g)
              for seq = (next g)
              when seq
              collect seq))))
\end{lstlisting}

The parsing process may be customized by using the \lstinline!:parser!
argument of \lstinline!make-seq-input! to pass an instance of a
subclass of \lstinline!bio-sequence-parser!. For example, passing a
\lstinline!raw-sequence-parser!  will result in a generator that
returns assoc lists of unprocessed sequence data instead of CLOS
sequence objects. The parser protocol is described in the API
reference.


\section{Bio-sequence alphabets}
\label{sec:alphabet-bioseq}

The permitted residues of DNA, RNA and amino-acid sequences are
represented by \lstinline!alphabet!s. Every \lstinline!bio-sequence!
instance contains its alphabet in a class-allocated slot, accessible
through the \lstinline!alphabet-of! reader. For reference, the list of
all available alphabets may be obtained by calling the
\lstinline!registered-alphabets! function, while individual alphabets
may be obtained by passing an alphabet name symbol (such as
\lstinline!:dna!, \lstinline!:rna! or \lstinline!:aa!) to the
\lstinline!find-alphabet! function. An alphabet object has several
slots, including its name and set of valid tokens, accessible via the
\lstinline!name-of! and \lstinline!tokens-of! readers, respectively.

An \lstinline!alphabet!'s set of tokens comprises all its unambiguous
and ambiguous tokens, plus a gap token. For example, the
\lstinline!:dna! alphabet contains characters for all of the IUPAC
codes (the \lstinline!:simple-dna! alphabet contains only 'a', 'c',
'g' and 't'). The \lstinline!size-of! method returns the size of an
alphabet which is defined as the number of tokens it contains. Higher
order alphabets may be constructed by using as tokens lists of
characters from other alphabets. In this way, the standard codon
alphabets are constructed.

To test whether a token is a member of an alphabet one can obtain the
alphabet's token list and use the standard CL \lstinline!member!
function, with an appropriate test predicate (the case of characters
is not significant). Alternatively, the \lstinline!memberp! method may
be used for convenience. Tokens that represent IUPAC ambiguity codes
may be analysed in the context their alphabets; they may be expanded
into equivalent lists of unambiguous tokens or tested to see whether
one subsumes the other i.e. that the unambiguous tokens represented by
one ambiguous token are a subset of those represented by another.

\begin{lstlisting}[caption={Using bio-sequence alphabets},
  label=lst:using-bioseq-alphabets]
  (in-package :bio-sequence)
  
  ;; List the names of the registered alphabets
  (mapcar #'name-of (registered-alphabets))

  ;; Make an assoc list mapping the alphabet names to their sizes
  (mapcar (lambda (x)
            (list (name-of x) (size-of x)))
          (registered-alphabets))

  ;; Is the character 't' in the DNA alphabet?
  (memberp #\t (find-alphabet :dna))

  ;; What characters does 'n' represent in the DNA alphabet?
  (enum-ambiguity #\n (find-alphabet :dna))

  ;; What unambiguous codons do 'nnn' represent in
  ;; the DNA codon alphabet?
  (enum-ambiguity '(#\n #\n #\n) (find-alphabet :dna-codons))

  ;; Does the character 'r' match the character 'n' in
  ;; the DNA alphabet?
  (subsumesp #\r #\n (find-alphabet :dna))

  ;; Does the codon 'aaa' match the codon 'raa' in
  ;; the DNA codon alphabet?
  (subsumesp '(#\a #\a #\a) '(#\r #\a #\a)
             (find-alphabet :dna-codons))
\end{lstlisting}


\section{Manipulating bio-sequences}
\label{sec:manipulating-bioseq}

\subsection{The components of a bio-sequence}
\label{sec:components-of-bioseq}

The simplest \lstinline!bio-sequence! objects contain little more than
slots for an identifier, an alphabet that describes the permitted
sequence residues and either a vector of residues or a length (in the
case of virtual sequences). While a description string slot is present
in all bio-sequence objects, it should be used with
care. \footnote{The description string is free text and therefore
  should only be used for round-tripping data between persistent
  storage. For example, it may be used to store the header line found
  in Fasta format files. It should not be computed upon.}  Nucleic
acid sequences also have a \lstinline!num-strands-of! method that may
be used to get and set the number of strands the sequence has.

The sequence residues themselves may be accessed through the
\lstinline!element-of! method (or its synonym
\lstinline!residue-of!). If the sequence has concrete residues (is not
virtual), the residues are \lstinline!setf!-able and thus may be
mutated. 

\begin{lstlisting}[caption={The components of a bio-sequence},
  label=lst:components-of-bioseq]
  (in-package :bio-sequence)

  ;; Create an anonymous DNA sequence. Print its identity, length
  ;; and make a list of its residues
  (let ((seq (make-dna "gtaaaacgacggccagtg")))
    (format t "id: ~a len: ~a residues: ~a~%"
            (identity-of seq) (length-of seq)
            (loop
               for i from 0 below (length-of seq)
               collect (element-of seq i))))

  ;; Create an anonymous DNA sequence and mutate all its residues
  ;; randomly
  (let ((seq (make-dna "gtaaaacgacggccagtg"))
        (dna (find-alphabet :simple-dna)))
    (loop
       for i from 0 below (length-of seq)
       do (setf (element-of seq i) (random-token-of dna))
       finally (return seq)))
  
  ;; Create an anonymous DNA sequence and mutate all its residues
  ;; randomly, this time using the with-sequence-residues macro
  (let ((seq (make-dna "gtaaaacgacggccagtg"))
        (dna (find-alphabet :simple-dna)))
    (with-sequence-residues (residue seq)
      (setf residue (random-token-of dna))))
\end{lstlisting}

The coordinate system used to address residues within a
\lstinline!bio-sequence! is a zero-based, inter-residue system
i.e. the boundaries between sequence residues are counted, starting
from zero. This is the same as the system used by the Chado genome
database \cite{gmod-chado} and equivalent to the zero-relative,
half-open residue-numbering system used by the UCSC genome database
\cite{PMID:18996895}. It is also the same as the indexing used by the
CL \lstinline!subseq! function, see Figure
\ref{fig:inter-residue-coords}. It would be rather inconvenient
to be required to use two inter-residue coordinates to address a
single residue, therefore an equivalent single-coordinate system is
provided; if a single inter-residue coordinate is provided, it
implicitly addresses the following residue. The resulting system is
equivalent to the standard addressing of CL vectors.

\begin{figure}[hb]
  \begin{center}
    \includegraphics[scale=1.0]{inter-residue-coordinates.pdf}
  \end{center}
  \caption{The bio-sequence residue coordinate system. Explicit
    inter-residue coordinates are shown in red, equivalent implicit
    vector-style coordinates in blue.}
  \label{fig:inter-residue-coords}
\end{figure}

\subsection{Testing bio-sequences}

The various biological types of sequence are implemented as CLOS
classes, meaning that method dispatch may be used to select
appropriate code branches in many cases. The predicates testing
\lstinline!bio-sequence! ambiguity, strand count and virtual state
fall into this category, meaning that it is an error to use them on
non-\lstinline!bio-sequence! objects.

In addition, a set of predicates are provided for testing directly the
biological type of \lstinline!bio-sequence! objects. These are normal
functions and will simply return NIL if passed a Lisp object that is
not a \lstinline!bio-sequence!.

\begin{lstlisting}[caption={Testing bio-sequences},
  label=lst:testing-bioseq]
  (in-package :bio-sequence)

  ;; Create and test anonymous sequences
  (defparameter *example-dna*
       (list (make-dna "acgt" :num-strands 1) (make-dna "acgn")))
  (defparameter *example-rna*
       (list (make-rna "acgu") (make-rna "acgn")))
  (defparameter *example-aa*
       (list (make-aa "MAD") (make-aa "MAB")))
  (defparameter *example-seq*
       (concatenate 'list *example-dna* *example-rna*
                    *example-aa*))

  ;; Generic function methods
  (mapcar #'simplep *example-seq*)
  (mapcar #'ambiguousp *example-seq*)
  (mapcar #'virtualp *example-seq*)
  
  (mapcar #'single-stranded-p *example-dna*)
  (mapcar #'double-stranded-p *example-rna*)

  ;; Returns T if all sequences have the same number of strands
  (apply #'same-strand-num-p *example-dna*)
  (apply #'same-strand-num-p *example-rna*)
  
  ;; Functions
  (mapcar #'bio-sequence-p *example-seq*)
  (mapcar #'dna-sequence-p *example-seq*)
  (mapcar #'rna-sequence-p *example-seq*)
  (mapcar #'aa-sequence-p *example-seq*)

  ;; Returns T if all sequences have the same biological type,
  ;; DNA, RNA or AA
  (apply #'same-biotype-p *example-dna*)
  (apply #'same-biotype-p *example-seq*)
\end{lstlisting}

\subsection{Coercing bio-sequences}
\label{sec:coerce-bioseq}

In the same way that CL types may be coerced, it is possible to coerce
\lstinline!bio-sequence! s, either to other \lstinline!bio-sequence!
types or to CL strings. In fact, coercion to a string is the main way
of producing a bare string rendering of a
\lstinline!bio-sequence!. Bio-sequence coercion differs from CL
coercion in that the function accepts \lstinline!:start! and
\lstinline!:end! arguments so that it is possible to coerce a
subsequence directly, without first using the \lstinline!subsequence!
method.

\begin{lstlisting}[caption={Coercing bio-sequences},
  label=lst:coercing-bioseq]
  (in-package :bio-sequence)

  ;; DNA may be coerced to RNA and vice versa
  (coerce-sequence (make-dna "acgt") 'rna-sequence
  (coerce-sequence (make-rna "acgu") 'dna-sequence)

  ;; A virtual sequence may be coerced to a concrete sequence
  (coerce-sequence (make-dna nil :length 4) 'dna-sequence)

  ;; Sequences may be coerced to strings
  (coerce-sequence (make-dna "acgt") 'string)
  (coerce-sequence (make-dna "acgt") 'string :start 0 :end 2)
  (coerce-sequence (make-aa "MAD") 'string)
\end{lstlisting}


\bibliographystyle{plain}
\bibliography{cl-genomic}

\end{document}
